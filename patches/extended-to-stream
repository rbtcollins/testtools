Bottom: caf225e2141d2f9d42a6f89a9c1c84855c967f60
Top:    d4c2205aa9a83226b9db9a7cecfe41f077f0de8e
Author: Robert Collins <robertc@robertcollins.net>
Date:   2013-02-15 23:58:56 +1300

Add an adapter to convert ExtendedTestResult to StreamResult.

This permits using code that uses any Python unittest test code
with a StreamResult.


---

diff --git a/NEWS b/NEWS
index 0b9ebc3..49eb168 100644
--- a/NEWS
+++ b/NEWS
@@ -20,6 +20,16 @@ Improvements
   ``StreamResult`` objects (each of which receives all the events).
   (Robert Collins)
 
+* New support class ``ExtendedToStreamResult`` which translates both regular
+  unittest TestResult API calls and the ExtendedTestResult API which testtools
+  has supported into the StreamResult API. ExtendedToStreamResult also forwards
+  calls made in the StreamResult API, permitting it to be used anywhere a 
+  StreamResult is used. Key TestResult query methods like wasSuccessful and
+  shouldStop are synchronised with the StreamResult API calls, but the detailed
+  statistics like the list of errors are not - a separate consumer will be
+  created to support that.
+  (Robert Collins)
+
 * New test support class ``testtools.testresult.doubles.StreamResult``, which
   captures all the StreamResult events. (Robert Collins)
 
diff --git a/testtools/__init__.py b/testtools/__init__.py
index 9e64be2..7fee4a4 100644
--- a/testtools/__init__.py
+++ b/testtools/__init__.py
@@ -9,6 +9,7 @@ __all__ = [
     'ErrorHolder',
     'ExpectedException',
     'ExtendedToOriginalDecorator',
+    'ExtendedToStreamDecorator',
     'FixtureSuite',
     'iterate_tests',
     'MultipleExceptions',
@@ -68,6 +69,7 @@ else:
     from testtools.testresult import (
         CopyStreamResult,
         ExtendedToOriginalDecorator,
+        ExtendedToStreamDecorator,
         MultiTestResult,
         StreamResult,
         Tagger,
diff --git a/testtools/testresult/__init__.py b/testtools/testresult/__init__.py
index f1ec047..9660822 100644
--- a/testtools/testresult/__init__.py
+++ b/testtools/testresult/__init__.py
@@ -5,6 +5,7 @@
 __all__ = [
     'CopyStreamResult',
     'ExtendedToOriginalDecorator',
+    'ExtendedToStreamDecorator',
     'MultiTestResult',
     'StreamResult',
     'Tagger',
@@ -18,6 +19,7 @@ __all__ = [
 from testtools.testresult.real import (
     CopyStreamResult,
     ExtendedToOriginalDecorator,
+    ExtendedToStreamDecorator,
     MultiTestResult,
     StreamResult,
     Tagger,
diff --git a/testtools/testresult/real.py b/testtools/testresult/real.py
index 1842608..0f33a71 100644
--- a/testtools/testresult/real.py
+++ b/testtools/testresult/real.py
@@ -886,6 +886,185 @@ class ExtendedToOriginalDecorator(object):
         return self.decorated.wasSuccessful()
 
 
+class ExtendedToStreamDecorator(TestResult):
+    """Permit using old TestResult API code with new StreamResult objects.
+    
+    This decorates a StreamResult and converts old (Python 2.6 / 2.7 /
+    Extended) TestResult API calls into StreamResult calls.
+
+    It also supports regular StreamResult calls, making it safe to wrap around
+    any StreamResult.
+    """
+
+    def __init__(self, decorated):
+        super(ExtendedToStreamDecorator, self).__init__()
+        self.decorated = decorated
+
+    def __repr__(self):
+        return '<%s %r>' % (self.__class__.__name__, self.decorated)
+
+    def __getattr__(self, name):
+        return getattr(self.decorated, name)
+
+    def startTest(self, test):
+        self.decorated.status(test.id(), 'inprogress')
+
+    def addError(self, test, err=None, details=None):
+        test_id = test.id()
+        try:
+            self._check_args(err, details)
+            if details is not None:
+                for name, content in details.items():
+                    mime_type = repr(content.content_type)
+                    for file_bytes in content.iter_bytes():
+                        self.decorated.file(name, file_bytes,
+                            mime_type=mime_type, test_id=test_id)
+                    self.decorated.file(name, _b(""), eof=True,
+                        mime_type=mime_type, test_id=test_id)
+                self.decorated.status(test_id, 'fail', test_tags=self.current_tags)
+        finally:
+            if self.failfast:
+                self.stop()
+
+    def addExpectedFailure(self, test, err=None, details=None):
+        self._check_args(err, details)
+        addExpectedFailure = getattr(
+            self.decorated, 'addExpectedFailure', None)
+        if addExpectedFailure is None:
+            return self.addSuccess(test)
+        if details is not None:
+            try:
+                return addExpectedFailure(test, details=details)
+            except TypeError:
+                # have to convert
+                err = self._details_to_exc_info(details)
+        return addExpectedFailure(test, err)
+
+    def addFailure(self, test, err=None, details=None):
+        try:
+            self._check_args(err, details)
+            if details is not None:
+                try:
+                    return self.decorated.addFailure(test, details=details)
+                except TypeError:
+                    # have to convert
+                    err = self._details_to_exc_info(details)
+            return self.decorated.addFailure(test, err)
+        finally:
+            if self.failfast:
+                self.stop()
+
+    def addSkip(self, test, reason=None, details=None):
+        self._check_args(reason, details)
+        addSkip = getattr(self.decorated, 'addSkip', None)
+        if addSkip is None:
+            return self.decorated.addSuccess(test)
+        if details is not None:
+            try:
+                return addSkip(test, details=details)
+            except TypeError:
+                # extract the reason if it's available
+                try:
+                    reason = details['reason'].as_text()
+                except KeyError:
+                    reason = _details_to_str(details)
+        return addSkip(test, reason)
+
+    def addUnexpectedSuccess(self, test, details=None):
+        try:
+            outcome = getattr(self.decorated, 'addUnexpectedSuccess', None)
+            if outcome is None:
+                try:
+                    test.fail("")
+                except test.failureException:
+                    return self.addFailure(test, sys.exc_info())
+            if details is not None:
+                try:
+                    return outcome(test, details=details)
+                except TypeError:
+                    pass
+            return outcome(test)
+        finally:
+            if self.failfast:
+                self.stop()
+
+    def addSuccess(self, test, details=None):
+        if details is not None:
+            try:
+                return self.decorated.addSuccess(test, details=details)
+            except TypeError:
+                pass
+        return self.decorated.addSuccess(test)
+
+    def _check_args(self, err, details):
+        param_count = 0
+        if err is not None:
+            param_count += 1
+        if details is not None:
+            param_count += 1
+        if param_count != 1:
+            raise ValueError("Must pass only one of err '%s' and details '%s"
+                % (err, details))
+
+    def _details_to_exc_info(self, details):
+        """Convert a details dict to an exc_info tuple."""
+        return (
+            _StringException,
+            _StringException(_details_to_str(details, special='traceback')),
+            None)
+
+    @property
+    def current_tags(self):
+        return getattr(
+            self.decorated, 'current_tags', self._tags.get_current_tags())
+
+    def done(self):
+        try:
+            return self.decorated.done()
+        except AttributeError:
+            return
+
+    def progress(self, offset, whence):
+        method = getattr(self.decorated, 'progress', None)
+        if method is None:
+            return
+        return method(offset, whence)
+
+    def startTestRun(self):
+        super(ExtendedToStreamDecorator, self).startTestRun()
+        self._saw_failure = False
+
+    def stop(self):
+        return self.decorated.stop()
+
+    def stopTest(self, test):
+        self._tags = self._tags.parent
+        pass
+
+    def stopTestRun(self):
+        try:
+            return self.decorated.stopTestRun()
+        except AttributeError:
+            return
+
+    def tags(self, new_tags, gone_tags):
+        method = getattr(self.decorated, 'tags', None)
+        if method is not None:
+            return method(new_tags, gone_tags)
+        else:
+            self._tags.change_tags(new_tags, gone_tags)
+
+    def time(self, a_datetime):
+        method = getattr(self.decorated, 'time', None)
+        if method is None:
+            return
+        return method(a_datetime)
+
+    def wasSuccessful(self):
+        return (super(ExtendedToStreamDecorator, self).wasSuccessful and 
+            not self._saw_failure)
+
+
 class TestResultDecorator(object):
     """General pass-through decorator.
 
diff --git a/testtools/tests/test_testresult.py b/testtools/tests/test_testresult.py
index 7ca1bdd..1a10892 100644
--- a/testtools/tests/test_testresult.py
+++ b/testtools/tests/test_testresult.py
@@ -20,6 +20,7 @@ from extras import safe_hasattr
 from testtools import (
     CopyStreamResult,
     ExtendedToOriginalDecorator,
+    ExtendedToStreamDecorator,
     MultiTestResult,
     PlaceHolder,
     StreamResult,
@@ -442,6 +443,12 @@ class TestAdaptedPython27TestResultContract(TestCase, DetailsContract):
         return ExtendedToOriginalDecorator(Python27TestResult())
 
 
+class TestAdaptedStreamResult(TestCase, DetailsContract):
+
+    def makeResult(self):
+        return ExtendedToStreamDecorator(StreamResult())
+
+
 class TestTestResultDecoratorContract(TestCase, StartTestRunContract):
 
     run_test_with = FullStackRunTest
@@ -542,6 +549,12 @@ class TestDoubleStreamResultContract(TestCase, TestStreamResultContract):
         return LoggingStreamResult()
 
 
+class TestExtendedToStreamDecoratorContract(TestCase, TestStreamResultContract):
+
+    def _make_result(self):
+        return ExtendedToStreamDecorator(StreamResult())
+
+
 class TestDoubleStreamResultEvents(TestCase):
 
     def test_startTestRun(self):
