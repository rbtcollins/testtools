Bottom: 0107b1aa6d80e62845164a5ab3783769ce41e599
Top:    4bf55edbdfd5f0f7f5559c316d0ae5391485c70c
Author: Robert Collins <robertc@robertcollins.net>
Date:   2013-02-15 23:58:56 +1300

Add an adapter to convert ExtendedTestResult to StreamResult.

This permits using code that uses any Python unittest test code
with a StreamResult.


---

diff --git a/NEWS b/NEWS
index 7290e1f..3bb4b2b 100644
--- a/NEWS
+++ b/NEWS
@@ -33,6 +33,16 @@ Improvements
 * New support class ``StreamFailfast`` which calls a ``TestControl`` instance
   to abort the test run when a failure is detected. (Robert Collins)
 
+* New support class ``ExtendedToStreamDecorator`` which translates both regular
+  unittest TestResult API calls and the ExtendedTestResult API which testtools
+  has supported into the StreamResult API. ExtendedToStreamDecorator also
+  forwards calls made in the StreamResult API, permitting it to be used
+  anywhere a StreamResult is used. Key TestResult query methods like
+  wasSuccessful and shouldStop are synchronised with the StreamResult API
+  calls, but the detailed statistics like the list of errors are not - a
+  separate consumer will be created to support that.
+  (Robert Collins)
+
 * New test support class ``testtools.testresult.doubles.StreamResult``, which
   captures all the StreamResult events. (Robert Collins)
 
diff --git a/doc/for-framework-folk.rst b/doc/for-framework-folk.rst
index c7b3904..4b60ace 100644
--- a/doc/for-framework-folk.rst
+++ b/doc/for-framework-folk.rst
@@ -178,6 +178,15 @@ with the result. e.g.::
     >>> # At stopTestRun() any incomplete buffered tests are announced.
     >>> result.stopTestRun()
 
+ExtendedToStreamDecorator
+-------------------------
+
+This is a hybrid object that combines both the ``Extended`` and ``Stream``
+``TestResult`` APIs into one class, but only emits ``StreamResult`` events.
+This is useful when a ``StreamResult`` stream is desired, but you cannot
+be sure that the tests which will run have been updated to the ``StreamResult``
+API.
+
 ThreadsafeStreamResult
 ----------------------
 
diff --git a/testtools/__init__.py b/testtools/__init__.py
index d30af69..73e60fd 100644
--- a/testtools/__init__.py
+++ b/testtools/__init__.py
@@ -9,6 +9,7 @@ __all__ = [
     'ErrorHolder',
     'ExpectedException',
     'ExtendedToOriginalDecorator',
+    'ExtendedToStreamDecorator',
     'FixtureSuite',
     'iterate_tests',
     'MultipleExceptions',
@@ -72,6 +73,7 @@ else:
     from testtools.testresult import (
         CopyStreamResult,
         ExtendedToOriginalDecorator,
+        ExtendedToStreamDecorator,
         MultiTestResult,
         StreamFailfast,
         StreamResult,
diff --git a/testtools/testresult/__init__.py b/testtools/testresult/__init__.py
index 435cb32..2827f0b 100644
--- a/testtools/testresult/__init__.py
+++ b/testtools/testresult/__init__.py
@@ -5,6 +5,7 @@
 __all__ = [
     'CopyStreamResult',
     'ExtendedToOriginalDecorator',
+    'ExtendedToStreamDecorator',
     'MultiTestResult',
     'StreamFailfast',
     'StreamResult',
@@ -22,6 +23,7 @@ __all__ = [
 from testtools.testresult.real import (
     CopyStreamResult,
     ExtendedToOriginalDecorator,
+    ExtendedToStreamDecorator,
     MultiTestResult,
     StreamFailfast,
     StreamResult,
diff --git a/testtools/testresult/real.py b/testtools/testresult/real.py
index b417cfe..5b23786 100644
--- a/testtools/testresult/real.py
+++ b/testtools/testresult/real.py
@@ -5,6 +5,7 @@
 __metaclass__ = type
 __all__ = [
     'ExtendedToOriginalDecorator',
+    'ExtendedToStreamDecorator',
     'MultiTestResult',
     'StreamFailfast',
     'StreamResult',
@@ -25,7 +26,7 @@ import unittest
 from extras import safe_hasattr
 from mimeparse import parse_mime_type
 
-from testtools.compat import all, str_is_unicode, _u
+from testtools.compat import all, str_is_unicode, _u, _b
 from testtools.content import (
     Content,
     text_content,
@@ -1110,6 +1111,135 @@ class ExtendedToOriginalDecorator(object):
         return self.decorated.wasSuccessful()
 
 
+class ExtendedToStreamDecorator(CopyStreamResult, StreamSummary, TestControl):
+    """Permit using old TestResult API code with new StreamResult objects.
+    
+    This decorates a StreamResult and converts old (Python 2.6 / 2.7 /
+    Extended) TestResult API calls into StreamResult calls.
+
+    It also supports regular StreamResult calls, making it safe to wrap around
+    any StreamResult.
+    """
+
+    def __init__(self, decorated):
+        super(ExtendedToStreamDecorator, self).__init__([decorated])
+        # Deal with failure to call startTestRun (old clients)
+        # - XXX note that as this forwards events we should defer
+        # this until a method / lookup is done without calling startTestRun and
+        # then trigger startTestRun.
+        self._tags = TagContext()
+        self.__now = None
+        StreamSummary.startTestRun(self)
+        # Deal with mismatched base class constructors.
+        TestControl.__init__(self)
+
+    def _get_failfast(self):
+        return len(self.targets) == 2
+    def _set_failfast(self, value):
+        if value:
+            if len(self.targets) == 2:
+                return
+            self.targets.append(StreamFailfast(self.stop))
+        else:
+            del self.targets[1:]
+    failfast = property(_get_failfast, _set_failfast)
+
+    def startTest(self, test):
+        self.status(test.id(), 'inprogress', timestamp=self._now())
+        self._tags = TagContext(self._tags)
+
+    def stopTest(self, test):
+        self._tags = self._tags.parent
+
+    def addError(self, test, err=None, details=None):
+        self._check_args(err, details)
+        self._convert(test, err, details, 'fail')
+    addFailure=addError
+
+    def _convert(self, test, err, details, status, reason=None):
+        test_id = test.id()
+        now = self._now()
+        if err is not None:
+            if details is None:
+                details = {}
+            details['traceback'] = TracebackContent(err, test)
+        if details is not None:
+            for name, content in details.items():
+                mime_type = repr(content.content_type)
+                for file_bytes in content.iter_bytes():
+                    self.file(name, file_bytes,
+                        mime_type=mime_type, test_id=test_id, timestamp=now)
+                self.file(name, _b(""), eof=True,
+                    mime_type=mime_type, test_id=test_id, timestamp=now)
+        if reason is not None:
+            self.file('reason', reason.encode('utf8'), eof=True,
+                mime_type="text/plain; charset=utf8", test_id=test_id,
+                timestamp=now)
+        self.status(test_id, status, test_tags=self.current_tags,
+            timestamp=now)
+
+    def addExpectedFailure(self, test, err=None, details=None):
+        self._check_args(err, details)
+        self._convert(test, err, details, 'xfail')
+
+    def addSkip(self, test, reason=None, details=None):
+        self._convert(test, None, details, 'skip', reason)
+
+    def addUnexpectedSuccess(self, test, details=None):
+        self._convert(test, None, details, 'uxsuccess')
+
+    def addSuccess(self, test, details=None):
+        self._convert(test, None, details, 'success')
+
+    def _check_args(self, err, details):
+        param_count = 0
+        if err is not None:
+            param_count += 1
+        if details is not None:
+            param_count += 1
+        if param_count != 1:
+            raise ValueError("Must pass only one of err '%s' and details '%s"
+                % (err, details))
+
+    def startTestRun(self):
+        super(ExtendedToStreamDecorator, self).startTestRun()
+        self._tags = TagContext()
+        self.shouldStop = False
+        self.__now = None
+
+    def stopTest(self, test):
+        self._tags = self._tags.parent
+        pass
+
+    @property
+    def current_tags(self):
+        """The currently set tags."""
+        return self._tags.get_current_tags()
+
+    def tags(self, new_tags, gone_tags):
+        """Add and remove tags from the test.
+
+        :param new_tags: A set of tags to be added to the stream.
+        :param gone_tags: A set of tags to be removed from the stream.
+        """
+        self._tags.change_tags(new_tags, gone_tags)
+
+    def _now(self):
+        """Return the current 'test time'.
+
+        If the time() method has not been called, this is equivalent to
+        datetime.now(), otherwise its the last supplied datestamp given to the
+        time() method.
+        """
+        if self.__now is None:
+            return datetime.datetime.now(utc)
+        else:
+            return self.__now
+
+    def time(self, a_datetime):
+        self.__now = a_datetime
+
+
 class TestResultDecorator(object):
     """General pass-through decorator.
 
diff --git a/testtools/tests/test_testresult.py b/testtools/tests/test_testresult.py
index ac31635..f7ab6b2 100644
--- a/testtools/tests/test_testresult.py
+++ b/testtools/tests/test_testresult.py
@@ -20,6 +20,7 @@ from extras import safe_hasattr
 from testtools import (
     CopyStreamResult,
     ExtendedToOriginalDecorator,
+    ExtendedToStreamDecorator,
     MultiTestResult,
     PlaceHolder,
     StreamFailfast,
@@ -447,6 +448,12 @@ class TestAdaptedPython27TestResultContract(TestCase, DetailsContract):
         return ExtendedToOriginalDecorator(Python27TestResult())
 
 
+class TestAdaptedStreamResult(TestCase, DetailsContract):
+
+    def makeResult(self):
+        return ExtendedToStreamDecorator(StreamResult())
+
+
 class TestTestResultDecoratorContract(TestCase, StartTestRunContract):
 
     run_test_with = FullStackRunTest
@@ -547,6 +554,12 @@ class TestDoubleStreamResultContract(TestCase, TestStreamResultContract):
         return LoggingStreamResult()
 
 
+class TestExtendedToStreamDecoratorContract(TestCase, TestStreamResultContract):
+
+    def _make_result(self):
+        return ExtendedToStreamDecorator(StreamResult())
+
+
 class TestStreamSummaryResultContract(TestCase, TestStreamResultContract):
 
     def _make_result(self):
@@ -708,6 +721,37 @@ class TestStreamToDict(TestCase):
             "application/octet-stream", repr(details['another file'].content_type))
 
 
+class TestExtendedToStreamDecorator(TestCase):
+
+    def test_explicit_time(self):
+        log = LoggingStreamResult()
+        result = ExtendedToStreamDecorator(log)
+        result.startTestRun()
+        now = datetime.datetime.now(utc)
+        result.time(now)
+        result.startTest(self)
+        result.addSuccess(self)
+        result.stopTest(self)
+        result.stopTestRun()
+        self.assertEqual([
+            ('startTestRun',),
+            ('status',
+             'testtools.tests.test_testresult.TestExtendedToStreamDecorator.test_explicit_time',
+             'inprogress',
+             None,
+             True,
+             None,
+             now),
+            ('status',
+             'testtools.tests.test_testresult.TestExtendedToStreamDecorator.test_explicit_time',
+             'success',
+              set(),
+              True,
+              None,
+              now),
+             ('stopTestRun',)], log._events)
+
+
 class TestStreamFailfast(TestCase):
 
     def test_inprogress(self):
