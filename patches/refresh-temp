Bottom: 3fe230284e2632e17c6735282ea68da794bb5bda
Top:    1193995dd306bd925e06b1ea09f1c819bce9a194
Author: Robert Collins <robertc@robertcollins.net>
Date:   2013-02-18 21:26:30 +1300

Refresh of stream-summary

---

diff --git a/NEWS b/NEWS
index 01084dd..4fd368c 100644
--- a/NEWS
+++ b/NEWS
@@ -20,6 +20,13 @@ Improvements
   ``StreamResult`` objects (each of which receives all the events).
   (Robert Collins)
 
+* New support class ``StreamSummary`` which summarises a ``StreamResult``
+  stream compatibly with ``TestResult`` code. (Robert Collins)
+
+* New support class ``StreamToDict`` which converts a ``StreamResult`` to a
+  series of dicts describing a test. Useful for writing trivial stream
+  analysers. (Robert Collins)
+
 * New test support class ``testtools.testresult.doubles.StreamResult``, which
   captures all the StreamResult events. (Robert Collins)
 
diff --git a/doc/for-framework-folk.rst b/doc/for-framework-folk.rst
index 3bb4222..d3b7c0f 100644
--- a/doc/for-framework-folk.rst
+++ b/doc/for-framework-folk.rst
@@ -157,6 +157,23 @@ Lastly we define the ``TestControl`` API which is used to provide the
 ``shouldStop`` and ``stop`` elements from ``TestResult``. Again, see the API
 documentation for ``testtools.TestControl``.
 
+StreamToDict
+------------
+
+A simplified API for dealing with ``StreamResult`` streams. Each test is
+buffered until it completes and then reported as a trivial dict. This makes
+writing analysers very easy - you can ignore all the plumbing and just work
+with the result. e.g.::
+
+    >>> from testtools import StreamToDict
+    >>> def handle_test(test_dict):
+    ...     print(test_dict['id'])
+    >>> result = StreamToDict(handle_test)
+    >>> result.startTestRun()
+    >>> # Run tests against result here.
+    >>> # At stopTestRun() any incomplete buffered tests are announced.
+    >>> result.stopTestRun()
+
 ThreadsafeStreamResult
 ----------------------
 
diff --git a/testtools/__init__.py b/testtools/__init__.py
index 2ea5542..b78bf53 100644
--- a/testtools/__init__.py
+++ b/testtools/__init__.py
@@ -28,6 +28,7 @@ __all__ = [
     'skipUnless',
     'StreamResult',
     'StreamSummary',
+    'StreamToDict',
     'ThreadsafeForwardingResult',
     'try_import',
     'try_imports',
@@ -72,6 +73,7 @@ else:
         MultiTestResult,
         StreamResult,
         StreamSummary,
+        StreamToDict,
         Tagger,
         TestByTestResult,
         TestResult,
diff --git a/testtools/testresult/__init__.py b/testtools/testresult/__init__.py
index 9aa6b7e..29ee39d 100644
--- a/testtools/testresult/__init__.py
+++ b/testtools/testresult/__init__.py
@@ -8,6 +8,7 @@ __all__ = [
     'MultiTestResult',
     'StreamResult',
     'StreamSummary',
+    'StreamToDict',
     'Tagger',
     'TestByTestResult',
     'TestResult',
@@ -22,6 +23,7 @@ from testtools.testresult.real import (
     MultiTestResult,
     StreamResult,
     StreamSummary,
+    StreamToDict,
     Tagger,
     TestByTestResult,
     TestResult,
diff --git a/testtools/testresult/real.py b/testtools/testresult/real.py
index afb0312..8d2999b 100644
--- a/testtools/testresult/real.py
+++ b/testtools/testresult/real.py
@@ -7,6 +7,8 @@ __all__ = [
     'ExtendedToOriginalDecorator',
     'MultiTestResult',
     'StreamResult',
+    'StreamSummary',
+    'StreamToDict',
     'Tagger',
     'TestResult',
     'TestResultDecorator',
@@ -415,117 +417,173 @@ class CopyStreamResult(StreamResult):
         domap(methodcaller('status', *args, **kwargs), self.targets)
 
 
-class StreamSummary(StreamResult):
-    """A specialised StreamResult that summarises a stream.
-    
-    The summary uses the same representation as the original
-    unittest.TestResult contract, allowing it to be consumed by any test
-    runner.
+class StreamToDict(StreamResult):
+    """A specialised StreamResult that emits a callback as tests complete.
+
+    Top level file attachments are simply discarded. Hung tests are detected
+    by stopTestRun and notified there and then.
+
+    The callback is passed a dict with the following keys:
+    * id: the test id.
+    * tags: The tags for the test. A set of unicode strings.
+    * details: A dict of file attachments - ``testtools.content.Content``
+        objects.
+    * status: One of the StreamResult status codes (including inprogress) or
+        'unknown' (used if only file events for a test were received...)
+
+    Only the most recent tags observed in the stream are reported.
     """
 
+    def __init__(self, on_test):
+        """Create a StreamToDict calling on_test on test completions.
+
+        :param on_test: A callback that accepts one parameter - a dict
+            describing a test.
+        """
+        super(StreamToDict, self).__init__()
+        self.on_test = on_test
+
     def startTestRun(self):
-        super(StreamSummary, self).startTestRun()
-        self.failures = []
-        self.errors = []
-        self.testsRun = 0
-        self.skipped = []
-        self.expectedFailures = []
-        self.unexpectedSuccesses = []
-        # Maps (id, route_code) -> a PlaceHolder
-        global PlaceHolder
-        from testtools.testcase import PlaceHolder
+        super(StreamToDict, self).startTestRun()
         self._inprogress = {}
-        self._handle_final_status = {
-            'success': self._success,
-            'skip': self._skip,
-            'exists': self._exists,
-            'fail': self._fail,
-            'xfail': self._xfail,
-            'uxsuccess': self._uxsuccess,
-            }
-
-    def stopTestRun(self):
-        super(StreamSummary, self).stopTestRun()
-        self.testsRun += len(self._inprogress)
-        for case in self._inprogress.values():
-            self.errors.append((case, "Test did not complete"))
-        self._inprogress.clear()
 
     def file(self, file_name, file_bytes, eof=False, mime_type=None,
         test_id=None, route_code=None, timestamp=None):
-        super(StreamSummary, self).file(file_name, file_bytes, eof=eof,
+        super(StreamToDict, self).file(file_name, file_bytes, eof=eof,
             mime_type=mime_type, test_id=test_id, route_code=route_code,
             timestamp=timestamp)
         key = self._ensure_key(test_id, route_code)
         if key:
             case = self._inprogress[key]
-            if file_name not in case._details:
+            if file_name not in case['details']:
                 if mime_type is None:
                     mime_type = 'application/octet-stream'
                 primary, sub, parameters = parse_mime_type(mime_type)
                 content_type = ContentType(primary, sub, parameters)
                 content_bytes = []
-                case._details[file_name] = Content(
+                case['details'][file_name] = Content(
                     content_type, lambda:content_bytes)
-            case._details[file_name].iter_bytes().append(file_bytes)
-
+            case['details'][file_name].iter_bytes().append(file_bytes)
+    
     def status(self, test_id, test_status, test_tags=None, runnable=True,
         route_code=None, timestamp=None):
-        super(StreamSummary, self).status(test_id, test_status,
+        super(StreamToDict, self).status(test_id, test_status,
             test_tags=test_tags, runnable=runnable, route_code=route_code,
             timestamp=timestamp)
         key = self._ensure_key(test_id, route_code)
+        # update fields
+        self._inprogress[key]['status'] = test_status
+        if test_tags is not None:
+            self._inprogress[key]['tags'] = test_tags
+        # notify completed tests.
         if test_status != 'inprogress':
-            case = self._inprogress.pop(key)
-            self._handle_final_status[test_status](
-                case, test_tags, runnable, route_code, timestamp)
-            self.testsRun += 1
+            self.on_test(self._inprogress.pop(key))
     
+    def stopTestRun(self):
+        super(StreamToDict, self).stopTestRun()
+        while self._inprogress:
+            self.on_test(self._inprogress.popitem()[1])
+
     def _ensure_key(self, test_id, route_code):
         if test_id is None:
             return
         key = (test_id, route_code)
         if key not in self._inprogress:
-            self._inprogress[key] = PlaceHolder(test_id, outcome='unknown')
+            self._inprogress[key] = {
+                'id': test_id,
+                'tags': set(),
+                'details': {},
+                'status': 'unknown'}
         return key
 
-    def _success(self, case, test_tags, runnable, route_code, timestamp):
+
+class StreamSummary(StreamToDict):
+    """A specialised StreamResult that summarises a stream.
+    
+    The summary uses the same representation as the original
+    unittest.TestResult contract, allowing it to be consumed by any test
+    runner.
+    """
+
+    def __init__(self):
+        super(StreamSummary, self).__init__(self._gather_test)
+        self._status_map = {
+            'inprogress': 'addFailure',
+            'unknown': 'addFailure',
+            'success': 'addSuccess',
+            'skip': 'addSkip',
+            'fail': 'addFailure',
+            'xfail': 'addExpectedFailure',
+            'uxsuccess': 'addUnexpectedSuccess',
+            }
+        self._handle_status = {
+            'success': self._success,
+            'skip': self._skip,
+            'exists': self._exists,
+            'fail': self._fail,
+            'xfail': self._xfail,
+            'uxsuccess': self._uxsuccess,
+            'unknown': self._incomplete,
+            'inprogress': self._incomplete,
+            }
+
+    def startTestRun(self):
+        super(StreamSummary, self).startTestRun()
+        self.failures = []
+        self.errors = []
+        self.testsRun = 0
+        self.skipped = []
+        self.expectedFailures = []
+        self.unexpectedSuccesses = []
+        # Circular import.
+        global PlaceHolder
+        from testtools.testcase import PlaceHolder
+
+    def wasSuccessful(self):
+        """Return False if any failure has occured.
+
+        Note that incomplete tests can only be detected when stopTestRun is
+        called, so that should be called before checking wasSuccessful.
+        """
+        return (not self.failures and not self.errors)
+
+    def _gather_test(self, test_dict):
+        self.testsRun += 1
+        if test_dict['status'] == 'exists':
+            return
+        outcome = self._status_map[test_dict['status']]
+        case = PlaceHolder(test_dict['id'], outcome=outcome,
+            details=test_dict['details'])
+        self._handle_status[test_dict['status']](case)
+
+    def _incomplete(self, case):
+        self.errors.append((case, "Test did not complete"))
+
+    def _success(self, case):
         pass
 
-    def _skip(self, case, test_tags, runnable, route_code, timestamp):
-        case._outcome = 'addSkip'
+    def _skip(self, case):
         if 'reason' not in case._details:
             reason = "Unknown"
         else:
             reason = case._details['reason'].as_text()
         self.skipped.append((case, reason))
 
-    def _exists(self, case, test_tags, runnable, route_code, timestamp):
+    def _exists(self, case):
         pass
 
-    def _fail(self, case, test_tags, runnable, route_code, timestamp):
-        case._outcome = 'addError'
+    def _fail(self, case):
         message = _details_to_str(case._details, special="traceback")
         self.errors.append((case, message))
 
-    def _xfail(self, case, test_tags, runnable, route_code, timestamp):
-        case._outcome = 'addExpectedFailure'
+    def _xfail(self, case):
         message = _details_to_str(case._details, special="traceback")
         self.expectedFailures.append((case, message))
 
-    def _uxsuccess(self, case, test_tags, runnable, route_code, timestamp):
+    def _uxsuccess(self, case):
         case._outcome = 'addUnexpectedSuccess'
         self.unexpectedSuccesses.append(case)
 
-    def wasSuccessful(self):
-        """Return False if any failure has occured.
-
-        Note that incomplete tests can only be detected when stopTestRun is
-        called, so that should be called before checking wasSuccessful.
-        """
-        return (not self.failures and
-            not self.errors)
-
 
 class MultiTestResult(TestResult):
     """A test result that dispatches to many test results."""
diff --git a/testtools/tests/test_testresult.py b/testtools/tests/test_testresult.py
index be57648..1b1f656 100644
--- a/testtools/tests/test_testresult.py
+++ b/testtools/tests/test_testresult.py
@@ -24,6 +24,7 @@ from testtools import (
     PlaceHolder,
     StreamResult,
     StreamSummary,
+    StreamToDict,
     Tagger,
     TestCase,
     TestResult,
@@ -550,6 +551,12 @@ class TestStreamSummaryResultContract(TestCase, TestStreamResultContract):
         return StreamSummary()
 
 
+class TestStreamToDictContract(TestCase, TestStreamResultContract):
+
+    def _make_result(self):
+        return StreamToDict(lambda x:None)
+
+
 class TestDoubleStreamResultEvents(TestCase):
 
     def test_startTestRun(self):
@@ -640,6 +647,59 @@ class TestCopyStreamResultCopies(TestCase):
                 ])))
 
 
+class TestStreamToDict(TestCase):
+
+    def test_hung_test(self):
+        tests = []
+        result = StreamToDict(tests.append)
+        result.startTestRun()
+        result.status('foo', 'inprogress')
+        self.assertEqual([], tests)
+        result.stopTestRun()
+        self.assertEqual([
+            {'id': 'foo', 'tags': set(), 'details': {}, 'status': 'inprogress'}
+            ], tests)
+
+    def test_all_terminal_states_reported(self):
+        tests = []
+        result = StreamToDict(tests.append)
+        result.startTestRun()
+        result.status('success', 'success')
+        result.status('skip', 'skip')
+        result.status('exists', 'exists')
+        result.status('fail', 'fail')
+        result.status('xfail', 'xfail')
+        result.status('uxsuccess', 'uxsuccess')
+        self.assertThat(tests, HasLength(6))
+        self.assertEqual(
+            ['success', 'skip', 'exists', 'fail', 'xfail', 'uxsuccess'],
+            [test['id'] for test in tests])
+        result.stopTestRun()
+        self.assertThat(tests, HasLength(6))
+
+    def test_files_reported(self):
+        tests = []
+        result = StreamToDict(tests.append)
+        result.startTestRun()
+        result.file("some log.txt", _b("1234 log message"), eof=True,
+            mime_type="text/plain; charset=utf8", test_id="foo.bar")
+        result.file("another file", _b("""Traceback..."""),
+            test_id="foo.bar")
+        result.stopTestRun()
+        self.assertThat(tests, HasLength(1))
+        test = tests[0]
+        self.assertEqual("foo.bar", test['id'])
+        self.assertEqual("unknown", test['status'])
+        details = test['details']
+        self.assertEqual(
+            _u("1234 log message"), details['some log.txt'].as_text())
+        self.assertEqual(
+            _b("Traceback..."),
+            _b('').join(details['another file'].iter_bytes()))
+        self.assertEqual(
+            "application/octet-stream", repr(details['another file'].content_type))
+
+
 class TestStreamSummary(TestCase):
 
     def test_attributes(self):
