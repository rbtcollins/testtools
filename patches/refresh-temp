Bottom: 903ea51e0de0562131943d5d6294afcb8bc8b43f
Top:    dc9ca450158f9f80a6d067a4417bee755e020e6a
Author: Robert Collins <robertc@robertcollins.net>
Date:   2013-03-20 10:16:15 +1300

Refresh of threadsafestreamresult

---

diff --git a/NEWS b/NEWS
index 88e3c22..0258834 100644
--- a/NEWS
+++ b/NEWS
@@ -28,7 +28,7 @@ Improvements
   (Robert Collins)
 
 * New support class ``ConcurrentStreamTestSuite`` for convenient construction
-  and utilisation of ``ThreadsafeStreamResult`` objects. (Robert Collins)
+  and utilisation of ``StreamToQueue`` objects. (Robert Collins)
 
 * New support class ``CopyStreamResult`` which forwards events onto multiple
   ``StreamResult`` objects (each of which receives all the events).
@@ -65,7 +65,7 @@ Improvements
   ``TestResult``) calls. This permits using un-migrated result objects with
   new runners / tests. (Robert Collins)
 
-* New support class ``ThreadsafeStreamResult`` for sending messages to one
+* New support class ``StreamToQueue`` for sending messages to one
   ``StreamResult`` from multiple threads. (Robert Collins)
 
 * New support class ``TimestampingStreamResult`` which adds a timestamp to
diff --git a/doc/for-framework-folk.rst b/doc/for-framework-folk.rst
index 921051f..c5b3b3f 100644
--- a/doc/for-framework-folk.rst
+++ b/doc/for-framework-folk.rst
@@ -233,13 +233,12 @@ response to events from the ``StreamResult`` API. Useful when outputting
 ``StreamResult`` events from a ``TestCase`` but the supplied ``TestResult``
 does not support the ``status`` and ``file`` methods.
 
-ThreadsafeStreamResult
-----------------------
+StreamToQueue
+-------------
 
 This is a ``StreamResult`` decorator for reporting tests from multiple threads
-at once. Each method takes out a lock around the decorated result to prevent
-race conditions. The ``startTestRun`` and ``stopTestRun`` methods are not
-forwarded to prevent the decorated result having them called multiple times.
+at once. Each method submits an event to a supplied Queue object as a simple
+dict. See ``ConcurrentStreamTestSuite`` for a convenient way to use this.
 
 TimestampingStreamResult
 ------------------------
diff --git a/testtools/__init__.py b/testtools/__init__.py
index 0296c05..e58f60a 100644
--- a/testtools/__init__.py
+++ b/testtools/__init__.py
@@ -35,9 +35,9 @@ __all__ = [
     'StreamTagger',
     'StreamToDict',
     'StreamToExtendedDecorator',
+    'StreamToQueue',
     'TestControl',
     'ThreadsafeForwardingResult',
-    'ThreadsafeStreamResult',
     'TimestampingStreamResult',
     'try_import',
     'try_imports',
@@ -88,6 +88,7 @@ else:
         StreamTagger,
         StreamToDict,
         StreamToExtendedDecorator,
+        StreamToQueue,
         Tagger,
         TestByTestResult,
         TestControl,
@@ -95,7 +96,6 @@ else:
         TestResultDecorator,
         TextTestResult,
         ThreadsafeForwardingResult,
-        ThreadsafeStreamResult,
         TimestampingStreamResult,
         )
     from testtools.testsuite import (
diff --git a/testtools/testresult/__init__.py b/testtools/testresult/__init__.py
index a3af5d5..bdef369 100644
--- a/testtools/testresult/__init__.py
+++ b/testtools/testresult/__init__.py
@@ -13,6 +13,7 @@ __all__ = [
     'StreamTagger',
     'StreamToDict',
     'StreamToExtendedDecorator',
+    'StreamToQueue',
     'Tagger',
     'TestByTestResult',
     'TestControl',
@@ -20,7 +21,6 @@ __all__ = [
     'TestResultDecorator',
     'TextTestResult',
     'ThreadsafeForwardingResult',
-    'ThreadsafeStreamResult',
     'TimestampingStreamResult',
     ]
 
@@ -35,6 +35,7 @@ from testtools.testresult.real import (
     StreamTagger,
     StreamToDict,
     StreamToExtendedDecorator,
+    StreamToQueue,
     Tagger,
     TestByTestResult,
     TestControl,
@@ -42,6 +43,5 @@ from testtools.testresult.real import (
     TestResultDecorator,
     TextTestResult,
     ThreadsafeForwardingResult,
-    ThreadsafeStreamResult,
     TimestampingStreamResult,
     )
diff --git a/testtools/testresult/real.py b/testtools/testresult/real.py
index 795d09c..bad2a3a 100644
--- a/testtools/testresult/real.py
+++ b/testtools/testresult/real.py
@@ -13,13 +13,13 @@ __all__ = [
     'StreamTagger',
     'StreamToDict',
     'StreamToExtendedDecorator',
+    'StreamToQueue',
     'Tagger',
     'TestControl',
     'TestResult',
     'TestResultDecorator',
     'ThreadsafeForwardingResult',
     'TimestampingStreamResult',
-    'ThreadsafeStreamResult',
     ]
 
 import datetime
@@ -27,8 +27,9 @@ from operator import methodcaller
 import sys
 import unittest
 
-from extras import safe_hasattr, try_import
+from extras import safe_hasattr, try_import, try_imports
 parse_mime_type = try_import('mimeparse.parse_mime_type')
+Queue = try_imports(['Queue.Queue', 'queue.Queue'])
 
 from testtools.compat import all, str_is_unicode, _u, _b
 from testtools.content import (
@@ -662,65 +663,6 @@ class TestControl(object):
         self.shouldStop = True
 
 
-class ThreadsafeStreamResult(StreamResult):
-    """A StreamResult which ensures the target does not receive mixed up calls.
-
-    Multiple ``ThreadsafeStreamResult`` objects can forward to the same target
-    and that target result will only ever receive one event at a time.
-
-    This is enforced using a semaphore, which further guarantees that events
-    will be sent atomically even if the ``ThreadsafeStreamResult`` callers are
-    in different threads.
-
-    Events have their route code updated on the way through. A code of None
-    becomes the supplied code, any other code is prefixed with the supplied
-    code + a hypen.
-
-    startTestRun and stopTestRun are not forwarded (as otherwise the recipients
-    would have these events called multiple times). 
-
-    ``ThreadsafeStreamResult`` is typically used by
-    ``ConcurrentStreamTestSuite``, which creates one ``ThreadsafeStreamResult``
-    per thread, each of which wraps the StreamResult that
-    ``ConcurrentStreamTestSuite.run()`` is called with.
-
-    Unlike ThreadsafeForwardingResult which this supercedes, no buffering takes
-    place - any event supplied to a ThreadsafeStreamResult will be forwarded
-    as soon as the semaphore is obtained, and the semaphore is only held around
-    one call.
-    """
-
-    def __init__(self, target, semaphore, routing_code):
-        """Create a ThreadsafeStreamResult forwarding to target.
-
-        :param target: A ``StreamResult``.
-        :param semaphore: A ``threading.Semaphore`` with limit 1.
-        :param routing_code: The routing code to apply to messages.
-        """
-        super(ThreadsafeStreamResult, self).__init__()
-        self.result = target
-        self.semaphore = semaphore
-        self.routing_code = routing_code
-
-    def status(self, test_id=None, test_status=None, test_tags=None,
-        runnable=True, file_name=None, file_bytes=None, eof=False,
-        mime_type=None, route_code=None, timestamp=None):
-        self.semaphore.acquire()
-        try:
-            self.result.status(test_id=test_id, test_status=test_status,
-                test_tags=test_tags, runnable=runnable, file_name=file_name,
-                file_bytes=file_bytes, eof=eof, mime_type=mime_type,
-                route_code=self.route_code(route_code), timestamp=timestamp)
-        finally:
-            self.semaphore.release()
-
-    def route_code(self, route_code):
-        """Adjust route_code on the way through."""
-        if route_code is None:
-            return self.routing_code
-        return self.routing_code + _u("/") + route_code
-
-
 class MultiTestResult(TestResult):
     """A test result that dispatches to many test results."""
 
@@ -1385,6 +1327,68 @@ class StreamToExtendedDecorator(StreamResult):
         case.run(self.decorated)
 
 
+class StreamToQueue(StreamResult):
+    """A StreamResult which enqueues events as a dict to a queue.Queue.
+
+    Events have their route code updated to include the route code
+    StreamToQueue was constructed with before they are submitted. If the event
+    route code is None, it is replaced with the StreamToQueue route code,
+    otherwise it is prefixed with the supplied code + a hyphen.
+
+    startTestRun and stopTestRun are forwarded to the queue. Implementors that
+    dequeue events back into StreamResult calls should take care not to call
+    startTestRun / stopTestRun on other StreamResult objects multiple times
+    (e.g. by filtering startTestRun and stopTestRun).
+
+    ``StreamToQueue`` is typically used by
+    ``ConcurrentStreamTestSuite``, which creates one ``StreamToQueue``
+    per thread, forwards status events to the the StreamResult that
+    ``ConcurrentStreamTestSuite.run()`` was called with, and uses the
+    stopTestRun event to trigger calling join() on the each thread.
+
+    Unlike ThreadsafeForwardingResult which this supercedes, no buffering takes
+    place - any event supplied to a StreamToQueue will be inserted into the
+    queue immediately.
+
+    Events are forwarded as a dict with a key ``event`` which is one of
+    ``startTestRun``, ``stopTestRun`` or ``status``. When ``event`` is 
+    ``status`` the dict also has keys matching the keyword arguments
+    of ``StreamResult.status``, otherwise it has one other key ``result`` which
+    is the result that invoked ``startTestRun``.
+    """
+
+    def __init__(self, queue, routing_code):
+        """Create a StreamToQueue forwarding to target.
+
+        :param queue: A ``queue.Queue`` to receive events.
+        :param routing_code: The routing code to apply to messages.
+        """
+        super(StreamToQueue, self).__init__()
+        self.queue = queue
+        self.routing_code = routing_code
+
+    def startTestRun(self):
+        self.queue.put(dict(event='startTestRun', result=self))
+
+    def status(self, test_id=None, test_status=None, test_tags=None,
+        runnable=True, file_name=None, file_bytes=None, eof=False,
+        mime_type=None, route_code=None, timestamp=None):
+        self.queue.put(dict(event='status', test_id=test_id,
+            test_status=test_status, test_tags=test_tags, runnable=runnable,
+            file_name=file_name, file_bytes=file_bytes, eof=eof,
+            mime_type=mime_type, route_code=self.route_code(route_code),
+            timestamp=timestamp))
+
+    def stopTestRun(self):
+        self.queue.put(dict(event='stopTestRun', result=self))
+
+    def route_code(self, route_code):
+        """Adjust route_code on the way through."""
+        if route_code is None:
+            return self.routing_code
+        return self.routing_code + _u("/") + route_code
+
+
 class TestResultDecorator(object):
     """General pass-through decorator.
 
diff --git a/testtools/tests/test_testresult.py b/testtools/tests/test_testresult.py
index e6eeb30..ea1d5af 100644
--- a/testtools/tests/test_testresult.py
+++ b/testtools/tests/test_testresult.py
@@ -16,7 +16,9 @@ import threading
 from unittest import TestSuite
 import warnings
 
-from extras import safe_hasattr
+from extras import safe_hasattr, try_imports
+
+Queue = try_imports(['Queue.Queue', 'queue.Queue'])
 
 from testtools import (
     CopyStreamResult,
@@ -30,6 +32,7 @@ from testtools import (
     StreamTagger,
     StreamToDict,
     StreamToExtendedDecorator,
+    StreamToQueue,
     Tagger,
     TestCase,
     TestControl,
@@ -38,7 +41,6 @@ from testtools import (
     TestByTestResult,
     TextTestResult,
     ThreadsafeForwardingResult,
-    ThreadsafeStreamResult,
     TimestampingStreamResult,
     testresult,
     )
@@ -584,6 +586,13 @@ class TestStreamToExtendedDecoratorContract(TestCase, TestStreamResultContract):
         return StreamToExtendedDecorator(ExtendedTestResult())
 
 
+class TestStreamToQueueContract(TestCase, TestStreamResultContract):
+
+    def _make_result(self):
+        queue = Queue()
+        return StreamToQueue(queue, "foo")
+
+
 class TestStreamFailFastContract(TestCase, TestStreamResultContract):
 
     def _make_result(self):
@@ -1686,49 +1695,50 @@ class TestMergeTags(TestCase):
 
 class TestThreadStreamResult(TestCase):
 
-    def make_result(self, target):
-        semaphore = threading.Semaphore(1)
-        return (ThreadsafeStreamResult(target, semaphore, "foo"),
-            semaphore)
+    def make_result(self):
+        queue = Queue()
+        return queue, StreamToQueue(queue, "foo")
 
     def test_status(self):
-        class CallbackStream(object):
-            def status(stream, test_id=None, test_status=None, test_tags=None,
-                runnable=True, file_name=None, file_bytes=None, eof=False,
-                mime_type=None, route_code=None, timestamp=None):
-                self.assertFalse(semaphore.acquire(False))
-                self.assertEqual("test", test_id)
-                self.assertEqual("fail", test_status)
-                self.assertEqual(set(["quux"]), test_tags)
-                self.assertEqual(False, runnable)
-                self.assertEqual("file", file_name)
-                self.assertEqual(_b("content"), file_bytes)
-                self.assertEqual(True, eof)
-                self.assertEqual("quux", mime_type)
-                self.assertEqual("test", test_id)
-                self.assertEqual(expected_route, route_code)
-                self.assertEqual(expected_time, timestamp)
-        result, semaphore = self.make_result(CallbackStream())
-        expected_route = "foo"
-        expected_time = None
+        def check_event(event_dict, route=None, time=None):
+            self.assertEqual("status", event_dict['event'])
+            self.assertEqual("test", event_dict['test_id'])
+            self.assertEqual("fail", event_dict['test_status'])
+            self.assertEqual(set(["quux"]), event_dict['test_tags'])
+            self.assertEqual(False, event_dict['runnable'])
+            self.assertEqual("file", event_dict['file_name'])
+            self.assertEqual(_b("content"), event_dict['file_bytes'])
+            self.assertEqual(True, event_dict['eof'])
+            self.assertEqual("quux", event_dict['mime_type'])
+            self.assertEqual("test", event_dict['test_id'])
+            self.assertEqual(route, event_dict['route_code'])
+            self.assertEqual(time, event_dict['timestamp'])
+        queue, result = self.make_result()
         result.status("test", "fail", test_tags=set(["quux"]), runnable=False,
             file_name="file", file_bytes=_b("content"), eof=True,
             mime_type="quux", route_code=None, timestamp=None)
-        expected_route = "foo/bar"
-        expected_time = datetime.datetime.now(utc)
+        self.assertEqual(1, queue.qsize())
+        a_time = datetime.datetime.now(utc)
         result.status("test", "fail", test_tags=set(["quux"]), runnable=False,
             file_name="file", file_bytes=_b("content"), eof=True,
-            mime_type="quux", route_code="bar", timestamp=expected_time)
+            mime_type="quux", route_code="bar", timestamp=a_time)
+        self.assertEqual(2, queue.qsize())
+        check_event(queue.get(False), route="foo", time=None)
+        check_event(queue.get(False), route="foo/bar", time=a_time)
 
     def testStartTestRun(self):
-        t = object()
-        result, semaphore = self.make_result(t)
+        queue, result = self.make_result()
         result.startTestRun()
+        self.assertEqual(
+            {'event':'startTestRun', 'result':result}, queue.get(False))
+        self.assertTrue(queue.empty())
 
     def testStopTestRun(self):
-        t = object()
-        result, semaphore = self.make_result(t)
-        result.startTestRun()
+        queue, result = self.make_result()
+        result.stopTestRun()
+        self.assertEqual(
+            {'event':'stopTestRun', 'result':result}, queue.get(False))
+        self.assertTrue(queue.empty())
 
 
 class TestExtendedToOriginalResultDecoratorBase(TestCase):
diff --git a/testtools/tests/test_testsuite.py b/testtools/tests/test_testsuite.py
index 56e2ef3..69dc668 100644
--- a/testtools/tests/test_testsuite.py
+++ b/testtools/tests/test_testsuite.py
@@ -179,7 +179,7 @@ class TestConcurrentStreamTestSuiteRun(TestCase):
         # Check the traceback loosely.
         self.assertThat(events[1][6].decode('utf8'), DocTestMatches("""\
 Traceback (most recent call last):
-  File "...testtools/testsuite.py", line 190, in _run_test
+  File "...testtools/testsuite.py", line 196, in _run_test
     test.run(process_result)
 TypeError: run() takes ...1 ...argument...2...given...
 """, doctest.ELLIPSIS))
diff --git a/testtools/testsuite.py b/testtools/testsuite.py
index 7c2bd58..d682481 100644
--- a/testtools/testsuite.py
+++ b/testtools/testsuite.py
@@ -122,8 +122,9 @@ class ConcurrentStreamTestSuite(unittest.TestSuite):
         :param suite: A suite to run concurrently. Each test will be run in its
             own thread.
         :param make_tests: A helper function to split the tests in the
-            ConcurrentTestSuite into some number of concurrently executing
-            sub-suites. make_tests must take a suite, and return an iterable
+            supplied suite into some number of concurrently executable
+            sub-suites. make_tests must take whatever the ``suite`` parameter
+            given to the constructor, and return an iterable
             of tuples. Each tuple must be of the form (case, route_code), where
             case is a TestCase-like object with a run(result) method, and
             route_code is either None or a unicode string.
@@ -144,13 +145,13 @@ class ConcurrentStreamTestSuite(unittest.TestSuite):
         ConcurrentTestSuite provides no special mechanism to stop the tests
         returned by make_tests, it is up to the made tests to honour the
         shouldStop attribute on the result object they are run with, which will
-        be set if an exception is raised in the thread which
-        ConcurrentTestSuite.run is called in.
+        be set if the test run is to be aborted.
 
         The tests are run with an ExtendedToStreamDecorator wrapped around a
-        ThreadsafeStreamResult forwarding to result. Tests can therefore be
-        either original unittest tests (or compatible tests), or new tests
-        that emit StreamResult events directly.
+        StreamToQueue instance. ConcurrentStreamTestSuite dequeues events from
+        the queue and forwards them to result. Tests can therefore be either
+        original unittest tests (or compatible tests), or new tests that emit
+        StreamResult events directly.
 
         :param result: A StreamResult instance. The caller is responsible for
             calling startTestRun on this instance prior to invoking suite.run,
@@ -160,21 +161,27 @@ class ConcurrentStreamTestSuite(unittest.TestSuite):
         try:
             threads = {}
             queue = Queue()
-            semaphore = threading.Semaphore(1)
             for test, route_code in tests:
+                to_queue = testtools.StreamToQueue(queue, route_code)
                 process_result = testtools.ExtendedToStreamDecorator(
-                    testtools.TimestampingStreamResult(
-                    testtools.ThreadsafeStreamResult(
-                        result, semaphore, route_code)))
-                reader_thread = threading.Thread(
+                    testtools.TimestampingStreamResult(to_queue))
+                runner_thread = threading.Thread(
                     target=self._run_test,
-                    args=(test, process_result, queue, route_code))
-                threads[test] = reader_thread, process_result
-                reader_thread.start()
+                    args=(test, process_result, route_code))
+                threads[to_queue] = runner_thread, process_result
+                runner_thread.start()
             while threads:
-                finished_test = queue.get()
-                threads[finished_test][0].join()
-                del threads[finished_test]
+                event_dict = queue.get()
+                event = event_dict.pop('event')
+                if event == 'status':
+                    result.status(**event_dict)
+                elif event == 'stopTestRun':
+                    thread = threads.pop(event_dict['result'])[0]
+                    thread.join()
+                elif event == 'startTestRun':
+                    pass
+                else:
+                    raise ValueError('unknown event type %r' % (event,))
         except:
             for thread, process_result in threads.values():
                 # Signal to each TestControl in the ExtendedToStreamDecorator
@@ -182,22 +189,19 @@ class ConcurrentStreamTestSuite(unittest.TestSuite):
                 process_result.stop()
             raise
 
-    def _run_test(self, test, process_result, queue, route_code):
+    def _run_test(self, test, process_result, route_code):
         process_result.startTestRun()
         try:
             try:
-                try:
-                    test.run(process_result)
-                except Exception as e:
-                    # The run logic itself failed.
-                    case = testtools.ErrorHolder(
-                        "broken-runner-'%s'" % (route_code,),
-                        error=sys.exc_info())
-                    case.run(process_result)
-            finally:
-                process_result.stopTestRun()
+                test.run(process_result)
+            except Exception as e:
+                # The run logic itself failed.
+                case = testtools.ErrorHolder(
+                    "broken-runner-'%s'" % (route_code,),
+                    error=sys.exc_info())
+                case.run(process_result)
         finally:
-            queue.put(test)
+            process_result.stopTestRun()
 
 
 class FixtureSuite(unittest.TestSuite):
