Bottom: 1a73ba1f78786eecbf6bbe771f5440529d8e13de
Top:    b3e4522a7c7e1340b1daa5130accd060b621bca1
Author: Robert Collins <robertc@robertcollins.net>
Date:   2013-02-19 21:03:36 +1300

Refresh of threadsafestreamresult

---

diff --git a/NEWS b/NEWS
index b7f488d..7000b20 100644
--- a/NEWS
+++ b/NEWS
@@ -16,6 +16,9 @@ Improvements
 * New class ``StreamResult`` which defines the API for the new result type.
   (Robert Collins)
 
+* New support class ``ConcurrentStreamTestSuite`` for convenient construction
+  and utilisation of ``ThreadsafeStreamResult`` objects. (Robert Collins)
+
 * New support class ``CopyStreamResult`` which forwards events onto multiple
   ``StreamResult`` objects (each of which receives all the events).
   (Robert Collins)
diff --git a/testtools/__init__.py b/testtools/__init__.py
index 5f108ba..cffbb9f 100644
--- a/testtools/__init__.py
+++ b/testtools/__init__.py
@@ -6,6 +6,7 @@ __all__ = [
     'clone_test_with_new_id',
     'CopyStreamResult',
     'ConcurrentTestSuite',
+    'ConcurrentStreamTestSuite',
     'ErrorHolder',
     'ExpectedException',
     'ExtendedToOriginalDecorator',
@@ -93,6 +94,7 @@ else:
         )
     from testtools.testsuite import (
         ConcurrentTestSuite,
+        ConcurrentStreamTestSuite,
         FixtureSuite,
         iterate_tests,
         )
diff --git a/testtools/tests/test_testsuite.py b/testtools/tests/test_testsuite.py
index d220709..8e842be 100644
--- a/testtools/tests/test_testsuite.py
+++ b/testtools/tests/test_testsuite.py
@@ -10,12 +10,15 @@ from extras import try_import
 
 from testtools import (
     ConcurrentTestSuite,
+    ConcurrentStreamTestSuite,
     iterate_tests,
     PlaceHolder,
     TestCase,
     )
+from testtools.compat import _u
 from testtools.testsuite import FixtureSuite, iterate_tests, sorted_tests
 from testtools.tests.helpers import LoggingResult
+from testtools.testresult.doubles import StreamResult as LoggingStream
 
 FunctionFixture = try_import('fixtures.FunctionFixture')
 
@@ -27,6 +30,7 @@ class Sample(TestCase):
     def test_method2(self):
         pass
 
+
 class TestConcurrentTestSuiteRun(TestCase):
 
     def test_trivial(self):
@@ -73,6 +77,63 @@ class TestConcurrentTestSuiteRun(TestCase):
         return tests[0], tests[1]
 
 
+class TestConcurrentStreamTestSuiteRun(TestCase):
+
+    def test_trivial(self):
+        result = LoggingStream()
+        test1 = Sample('test_method1')
+        test2 = Sample('test_method2')
+        original_suite = unittest.TestSuite([test1, test2])
+        suite = ConcurrentStreamTestSuite(original_suite, self.split_suite)
+        suite.run(result)
+        def freeze(set_or_none):
+            if set_or_none is None:
+                return set_or_none
+            return frozenset(set_or_none)
+        # Ignore event order: we're testing the code is all glued together,
+        # which just means we can pump events through and they get route codes
+        # added appropriately.
+        self.assertEqual(set([
+            ('status',
+             'testtools.tests.test_testsuite.Sample.test_method1',
+             'inprogress',
+             None,
+             True,
+             '0',
+             None,
+             ),
+            ('status',
+             'testtools.tests.test_testsuite.Sample.test_method1',
+             'success',
+             frozenset(),
+             True,
+             '0',
+             None,
+             ),
+            ('status',
+             'testtools.tests.test_testsuite.Sample.test_method2',
+             'inprogress',
+             None,
+             True,
+             '1',
+             None,
+             ),
+            ('status',
+             'testtools.tests.test_testsuite.Sample.test_method2',
+             'success',
+             frozenset(),
+             True,
+             '1',
+             None,
+             ),
+            ]), set(event[0:3] + (freeze(event[3]),) + event[4:6] + (None,)
+                for event in result._events))
+
+    def split_suite(self, suite):
+        tests = list(iterate_tests(suite))
+        return (tests[0], _u("0")), (tests[1], _u("1"))
+
+
 class TestFixtureSuite(TestCase):
 
     def setUp(self):
diff --git a/testtools/testsuite.py b/testtools/testsuite.py
index 39a68d7..b45ecf5 100644
--- a/testtools/testsuite.py
+++ b/testtools/testsuite.py
@@ -5,6 +5,7 @@
 __metaclass__ = type
 __all__ = [
   'ConcurrentTestSuite',
+  'ConcurrentStreamTestSuite',
   'filter_by_ids',
   'iterate_tests',
   'sorted_tests',
@@ -104,6 +105,82 @@ class ConcurrentTestSuite(unittest.TestSuite):
             queue.put(test)
 
 
+class ConcurrentStreamTestSuite(unittest.TestSuite):
+    """A TestSuite whose run() parallelises."""
+
+    def __init__(self, suite, make_tests):
+        """Create a ConcurrentTestSuite to execute suite.
+
+        :param suite: A suite to run concurrently. Each test will be run in its
+            own thread.
+        :param make_tests: A helper function to split the tests in the
+            ConcurrentTestSuite into some number of concurrently executing
+            sub-suites. make_tests must take a suite, and return an iterable
+            of tuples. Each tuple must be of the form (case, route_code), where
+            case is a TestCase-like object with a run(result) mthod, and
+            route_code is either None or a unicode string.
+        """
+        super(ConcurrentStreamTestSuite, self).__init__([suite])
+        self.make_tests = make_tests
+
+    def run(self, result):
+        """Run the tests concurrently.
+
+        This calls out to the provided make_tests helper to determine the
+        concurrency to use and to assign routing codes to each worker. It
+        is possible to also decorate or alter the tests in make_tests if
+        desired (though that can also be done at construction time).
+
+        ConcurrentTestSuite provides no special mechanism to stop the tests
+        returned by make_tests, it is up to the made tests to honour the
+        shouldStop attribute on the result object they are run with, which will
+        be set if an exception is raised in the thread which
+        ConcurrentTestSuite.run is called in.
+
+        The tests are run with an ExtendedToStreamDecorator wrapped around a
+        ThreadsafeStreamResult forwarding to result. Tests can therefore be
+        either original unittest tests (or compatible tests), or new tests
+        that emit StreamResult events directly.
+
+        :param result: A StreamResult instance. The caller is responsible for
+            calling startTestRun on this instance prior to invoking suite.run,
+            and stopTestRun subsequent to the run method returning.
+        """
+        tests = self.make_tests(self)
+        try:
+            threads = {}
+            queue = Queue()
+            semaphore = threading.Semaphore(1)
+            for test, route_code in tests:
+                process_result = testtools.ExtendedToStreamDecorator(
+                    testtools.ThreadsafeStreamResult(
+                        result, semaphore, route_code))
+                reader_thread = threading.Thread(
+                    target=self._run_test, args=(test, process_result, queue))
+                threads[test] = reader_thread, process_result
+                reader_thread.start()
+            while threads:
+                finished_test = queue.get()
+                threads[finished_test][0].join()
+                del threads[finished_test]
+        except:
+            for thread, process_result in threads.values():
+                # Signal to each TestControl in the ExtendedToStreamDecorator
+                # that the thread should stop running tests and cleanup
+                process_result.stop()
+            raise
+
+    def _run_test(self, test, process_result, queue):
+        process_result.startTestRun()
+        try:
+            try:
+                test.run(process_result)
+            finally:
+                process_result.stopTestRun()
+        finally:
+            queue.put(test)
+
+
 class FixtureSuite(unittest.TestSuite):
 
     def __init__(self, fixture, tests):
