Bottom: 157256fe1ec0b129293d7284b24508f4c58cdc02
Top:    62785bf210e500f1f4b02ae76513e29632b34c75
Author: Robert Collins <robertc@robertcollins.net>
Date:   2013-02-24 21:09:19 +1300

Refresh of streamresult-router

---

diff --git a/NEWS b/NEWS
index 0b9de9d..b348731 100644
--- a/NEWS
+++ b/NEWS
@@ -67,6 +67,10 @@ Improvements
 * New test support class ``testtools.testresult.doubles.StreamResult``, which
   captures all the StreamResult events. (Robert Collins)
 
+* ``StreamResultRouter`` added. This is useful for demultiplexing - e.g. for
+  partitioning analysis of events or sending feedback encapsulated in
+  StreamResult events back to their source. (Robert Collins)
+
 0.9.29
 ~~~~~~
 
diff --git a/doc/for-framework-folk.rst b/doc/for-framework-folk.rst
index a4b54d2..612894c 100644
--- a/doc/for-framework-folk.rst
+++ b/doc/for-framework-folk.rst
@@ -212,6 +212,33 @@ passing the events via this decorator to get timestamped data. As long as
 no buffering/queueing or blocking happen before the timestamper sees the event
 the timestamp will be as accurate as if the original event had it.
 
+StreamResultRouter
+------------------
+
+This is a ``StreamResult`` which forwards events to an arbitrary set of target
+``StreamResult`` objects. Events that have no forwarding rule are passed onto
+an fallback ``StreamResult`` for processing. The mapping can be changed at
+runtime, allowing great flexability and responsiveness to changes. Because
+The mapping can change dynamically and there could be the same recipient for
+two different maps, ``startTestRun`` and ``stopTestRun`` are not forwarded by
+``StreamResultRouter`` - that is up to the user to arrange.
+
+If no fallback has been supplied, an unroutable event will raise an exception.
+
+For instance::
+
+    >>> router = StreamResultRouter()
+    >>> sink = doubles.StreamResult()
+    >>> router.map(sink, 'route_code_prefix', route_prefix='0',
+    ...     consume_route=True)
+    >>> router.status(test_id='foo', route_code='0/1', test_status='uxsuccess')
+
+Would remove the ``0/`` from the route_code and forward the event like so::
+
+    >>> sink.status('test_id=foo', route_code='1', test_status='uxsuccess')
+
+See ``pydoc testtools.StreamResultRouter`` for details.
+
 TestResult.addSkip
 ------------------
 
diff --git a/testtools/__init__.py b/testtools/__init__.py
index a56200d..39de698 100644
--- a/testtools/__init__.py
+++ b/testtools/__init__.py
@@ -30,6 +30,7 @@ __all__ = [
     'skipUnless',
     'StreamFailfast',
     'StreamResult',
+    'StreamResultRouter',
     'StreamSummary',
     'StreamToDict',
     'StreamToExtendedDecorator',
@@ -81,6 +82,7 @@ else:
         MultiTestResult,
         StreamFailfast,
         StreamResult,
+        StreamResultRouter,
         StreamSummary,
         StreamToDict,
         StreamToExtendedDecorator,
diff --git a/testtools/testresult/__init__.py b/testtools/testresult/__init__.py
index 940846d..9f8c789 100644
--- a/testtools/testresult/__init__.py
+++ b/testtools/testresult/__init__.py
@@ -9,6 +9,7 @@ __all__ = [
     'MultiTestResult',
     'StreamFailfast',
     'StreamResult',
+    'StreamResultRouter',
     'StreamSummary',
     'StreamToDict',
     'StreamToExtendedDecorator',
@@ -30,6 +31,7 @@ from testtools.testresult.real import (
     MultiTestResult,
     StreamFailfast,
     StreamResult,
+    StreamResultRouter,
     StreamSummary,
     StreamToDict,
     StreamToExtendedDecorator,
diff --git a/testtools/testresult/real.py b/testtools/testresult/real.py
index 231085e..835a013 100644
--- a/testtools/testresult/real.py
+++ b/testtools/testresult/real.py
@@ -416,6 +416,81 @@ class StreamFailfast(StreamResult):
             self.callback()
 
 
+class StreamResultRouter(StreamResult):
+    """A StreamResult that routes events.
+
+    StreamResultRouter forwards received events to another StreamResult object,
+    selected by a dynamic forwarding policy. Events where no destination is
+    found are forwarded to the fallback StreamResult, or an error is raised.
+
+    Typical use is to construct a router with a fallback and then either
+    create up front mapping rules, or create them as-needed from the fallback
+    handler::
+
+      >>> router = StreamResultRouter()
+      >>> sink = doubles.StreamResult()
+      >>> router.map(sink, 'route_code_prefix', route_prefix='0',
+      ...     consume_route=True)
+      >>> router.status(test_id='foo', route_code='0/1', test_status='uxsuccess')
+
+    StreamResultRouter has no buffering and startTestRun and stopTestRun are
+    no-ops: they are neither forwarded (because some map targets might be
+    called multiple times), nor have any effect on StreamResultRouter itself.
+
+    There is no a-priori defined lookup order for routes: if they are ambiguous
+    the behaviour is undefined. Only a single route is chosen for any event.
+    """
+
+    def __init__(self, fallback=None):
+        """Construct a StreamResultRouter with optional fallback.
+
+        :param fallback: A StreamResult to forward events to when no route
+            exists for them.
+        """
+        self.fallback = fallback
+        self._route_code_prefixes = {}
+
+    def status(self, **kwargs):
+        route_code = kwargs.get('route_code', None)
+        if route_code is not None:
+            prefix = route_code.split('/')[0]
+        else:
+            prefix = route_code
+        target, consume_route = self._route_code_prefixes.get(
+            prefix, (self.fallback, False))
+        if route_code is not None and consume_route:
+            route_code = route_code[len(prefix) + 1:]
+            if not route_code:
+                route_code = None
+            kwargs['route_code'] = route_code
+        target.status(**kwargs)
+
+    def map(self, sink, policy, **policy_args):
+        """Route events to sink when they match a given policy.
+
+        :param sink: A StreamResult to receive events.
+        :param policy: A routing policy. Valid policies are
+            'route_code_prefix'.
+
+        route_code_prefix routes events based on a prefix of the route code in
+        the event. It takes the following arguments::
+        :param route_prefix: A prefix to match on - e.g. '0'.
+        :param consume_route: If True, remove the prefix from the route_code
+            when forwarding events.
+        :raises: ValueError if the policy is unknown
+        :raises: TypeError if the policy is given arguments it cannot handle.
+        """
+        if policy != 'route_code_prefix':
+            raise ValueError("bad policy %r" % (policy,))
+        self._map_route_code_prefix(sink, **policy_args)
+
+    def _map_route_code_prefix(self, sink, route_prefix, consume_route=False):
+        if '/' in route_prefix:
+            raise TypeError(
+                "%r is more than one route step long" % (route_prefix,))
+        self._route_code_prefixes[route_prefix] = (sink, consume_route)
+
+
 class StreamToDict(StreamResult):
     """A specialised StreamResult that emits a callback as tests complete.
 
diff --git a/testtools/tests/test_testresult.py b/testtools/tests/test_testresult.py
index cc21d7d..e38e0d5 100644
--- a/testtools/tests/test_testresult.py
+++ b/testtools/tests/test_testresult.py
@@ -25,6 +25,7 @@ from testtools import (
     PlaceHolder,
     StreamFailfast,
     StreamResult,
+    StreamResultRouter,
     StreamSummary,
     StreamToDict,
     StreamToExtendedDecorator,
@@ -589,6 +590,12 @@ class TestStreamFailfastContract(TestCase, TestStreamResultContract):
         return StreamFailfast(lambda:None)
 
 
+class TestStreamResultRouterContract(TestCase, TestStreamResultContract):
+
+    def _make_result(self):
+        return StreamResultRouter(StreamResult())
+
+
 class TestDoubleStreamResultEvents(TestCase):
 
     def test_startTestRun(self):
@@ -1601,6 +1608,86 @@ class TestMergeTags(TestCase):
             expected, _merge_tags(current_tags, changing_tags))
 
 
+class TestStreamResultRouter(TestCase):
+
+    def test_no_fallback_errors(self):
+        self.assertRaises(Exception, StreamResultRouter().status, test_id='f')
+
+    def test_fallback_calls(self):
+        fallback = LoggingStreamResult()
+        StreamResultRouter(fallback).status(test_id='foo')
+        self.assertEqual([
+            ('status', 'foo', None, None, True, None, None, False, None, None,
+             None)],
+            fallback._events)
+
+    def test_map_bad_policy(self):
+        router = StreamResultRouter()
+        target = LoggingStreamResult()
+        self.assertRaises(ValueError, router.map, target, 'route_code_prefixa',
+            route_prefix='0')
+
+    def test_map_extra_policy_arg(self):
+        router = StreamResultRouter()
+        target = LoggingStreamResult()
+        self.assertRaises(TypeError, router.map, target, 'route_code_prefix',
+            route_prefix='0', foo=1)
+
+    def test_map_missing_prefix(self):
+        router = StreamResultRouter()
+        target = LoggingStreamResult()
+        self.assertRaises(TypeError, router.map, target, 'route_code_prefix')
+
+    def test_map_slash_in_prefix(self):
+        router = StreamResultRouter()
+        target = LoggingStreamResult()
+        self.assertRaises(TypeError, router.map, target, 'route_code_prefix',
+            route_prefix='0/')
+
+    def test_map_route_code_consume_False(self):
+        fallback = LoggingStreamResult()
+        target = LoggingStreamResult()
+        router = StreamResultRouter(fallback)
+        router.map(target, 'route_code_prefix', route_prefix='0')
+        router.status(test_id='foo', route_code='0')
+        router.status(test_id='foo', route_code='0/1')
+        router.status(test_id='foo')
+        self.assertEqual([
+            ('status', 'foo', None, None, True, None, None, False, None, '0',
+             None),
+            ('status', 'foo', None, None, True, None, None, False, None, '0/1',
+             None),
+            ],
+            target._events)
+        self.assertEqual([
+            ('status', 'foo', None, None, True, None, None, False, None, None,
+             None),
+            ],
+            fallback._events)
+
+    def test_map_route_code_consume_True(self):
+        fallback = LoggingStreamResult()
+        target = LoggingStreamResult()
+        router = StreamResultRouter(fallback)
+        router.map(
+            target, 'route_code_prefix', route_prefix='0', consume_route=True)
+        router.status(test_id='foo', route_code='0') # -> None
+        router.status(test_id='foo', route_code='0/1') # -> 1
+        router.status(test_id='foo', route_code='1') # -> fallback as-is.
+        self.assertEqual([
+            ('status', 'foo', None, None, True, None, None, False, None, None,
+             None),
+            ('status', 'foo', None, None, True, None, None, False, None, '1',
+             None),
+            ],
+            target._events)
+        self.assertEqual([
+            ('status', 'foo', None, None, True, None, None, False, None, '1',
+             None),
+            ],
+            fallback._events)
+
+
 class TestThreadStreamResult(TestCase):
 
     def make_result(self, target):
