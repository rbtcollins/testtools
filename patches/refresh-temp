Bottom: 8e69b322cde926446d7c63ce367e089f2c061fb3
Top:    1a73ba1f78786eecbf6bbe771f5440529d8e13de
Author: Robert Collins <robertc@robertcollins.net>
Date:   2013-02-19 16:22:09 +1300

Refresh of threadsafestreamresult

---

diff --git a/NEWS b/NEWS
index 7de24c2..b7f488d 100644
--- a/NEWS
+++ b/NEWS
@@ -48,6 +48,9 @@ Improvements
   ``TestResult``) calls. This permits using un-migrated result objects with
   new runners / tests. (Robert Collins)
 
+* New support class ``ThreadsafeStreamResult`` for sending messages to one
+  ``StreamResult`` from multiple threads. (Robert Collins)
+
 * New test support class ``testtools.testresult.doubles.StreamResult``, which
   captures all the StreamResult events. (Robert Collins)
 
diff --git a/doc/for-framework-folk.rst b/doc/for-framework-folk.rst
index 736beff..1d02cc0 100644
--- a/doc/for-framework-folk.rst
+++ b/doc/for-framework-folk.rst
@@ -311,6 +311,20 @@ ConcurrentTestSuite uses the helper to get a number of separate runnable
 objects with a run(result), runs them all in threads using the
 ThreadsafeForwardingResult to coalesce their activity.
 
+ConcurrentStreamTestSuite
+-------------------------
+
+A variant of ConcurrentTestSuite that uses the new StreamResult API instead of
+the TestResult API. ConcurrentStreamTestSuite coordinates running some number
+of test/suites concurrently, with one ThreadsafeStreamResult per test/suite.
+
+Each test/suite gets given its own ExtendedToStreamDecorator wrapped
+ThreadsafeStreamResult instance, forwarding onto the StreamResult that
+ConcurrentStreamTestSuite.run was called with.
+
+ConcurrentStreamTestSuite is a thin shim and it is easy to implement your own
+specialised form if that is needed.
+
 FixtureSuite
 ------------
 
diff --git a/testtools/__init__.py b/testtools/__init__.py
index 6a965cd..5f108ba 100644
--- a/testtools/__init__.py
+++ b/testtools/__init__.py
@@ -34,6 +34,7 @@ __all__ = [
     'StreamToExtendedDecorator',
     'TestControl',
     'ThreadsafeForwardingResult',
+    'ThreadsafeStreamResult',
     'try_import',
     'try_imports',
     ]
@@ -88,6 +89,7 @@ else:
         TestResultDecorator,
         TextTestResult,
         ThreadsafeForwardingResult,
+        ThreadsafeStreamResult,
         )
     from testtools.testsuite import (
         ConcurrentTestSuite,
diff --git a/testtools/testresult/__init__.py b/testtools/testresult/__init__.py
index 8f0fd76..3417ed5 100644
--- a/testtools/testresult/__init__.py
+++ b/testtools/testresult/__init__.py
@@ -19,6 +19,7 @@ __all__ = [
     'TestResultDecorator',
     'TextTestResult',
     'ThreadsafeForwardingResult',
+    'ThreadsafeStreamResult',
     ]
 
 from testtools.testresult.real import (
@@ -38,4 +39,5 @@ from testtools.testresult.real import (
     TestResultDecorator,
     TextTestResult,
     ThreadsafeForwardingResult,
+    ThreadsafeStreamResult,
     )
diff --git a/testtools/testresult/real.py b/testtools/testresult/real.py
index cbb8edf..81ac9b9 100644
--- a/testtools/testresult/real.py
+++ b/testtools/testresult/real.py
@@ -16,6 +16,7 @@ __all__ = [
     'TestResult',
     'TestResultDecorator',
     'ThreadsafeForwardingResult',
+    'ThreadsafeStreamResult',
     ]
 
 import datetime
@@ -629,6 +630,81 @@ class TestControl(object):
         self.shouldStop = True
 
 
+class ThreadsafeStreamResult(StreamResult):
+    """A StreamResult which ensures the target does not receive mixed up calls.
+
+    Multiple ``ThreadsafeStreamResult`` objects can forward to the same target
+    and that target result will only ever receive one event at a time.
+
+    This is enforced using a semaphore, which further guarantees that events
+    will be sent atomically even if the ``ThreadsafeStreamResult`` callers are
+    in different threads.
+
+    Events have their route code updated on the way through. A code of None
+    becomes the supplied code, any other code has is prefixed with the supplied
+    code hypen, old code.
+
+    startTestRun and stopTestRun are not forwarded (as otherwise the recipients
+    would have these events called multiple times). 
+
+    ``ThreadsafeStreamResult`` is typically used by
+    ``ConcurrentStreamTestSuite``, which creates one ``ThreadsafeStreamResult``
+    per thread, each of which wraps the StreamResult that
+    ``ConcurrentStreamTestSuite.run()`` is called with.
+
+    Unlike ThreadsafeForwardingResult which this supercedes, no buffering takes
+    place - any event supplied to a ThreadsafeStreamResult will be forwarded
+    as soon as the semaphore is obtained, and the semaphore is only held around
+    one call.
+    """
+
+    def __init__(self, target, semaphore, routing_code):
+        """Create a ThreadsafeStreamResult forwarding to target.
+
+        :param target: A ``StreamResult``.
+        :param semaphore: A ``threading.Semaphore`` with limit 1.
+        :param routing_code: The routing code to apply to messages.
+        """
+        super(ThreadsafeStreamResult, self).__init__()
+        self.result = target
+        self.semaphore = semaphore
+        self.routing_code = routing_code
+
+    def estimate(self, count, route_code=None, timestamp=None):
+        self.semaphore.acquire()
+        try:
+            self.result.estimate(count, route_code=self.route_code(route_code),
+                timestamp=timestamp)
+        finally:
+            self.semaphore.release()
+
+    def file(self, file_name, file_bytes, eof=False, mime_type=None,
+        test_id=None, route_code=None, timestamp=None):
+        self.semaphore.acquire()
+        try:
+            self.result.file(file_name, file_bytes, eof=eof,
+                mime_type=mime_type, test_id=test_id,
+                route_code=self.route_code(route_code), timestamp=timestamp)
+        finally:
+            self.semaphore.release()
+
+    def status(self, test_id, test_status, test_tags=None, runnable=True,
+        route_code=None, timestamp=None):
+        self.semaphore.acquire()
+        try:
+            self.result.status(test_id, test_status, test_tags=test_tags,
+                runnable=runnable, route_code=self.route_code(route_code),
+                timestamp=timestamp)
+        finally:
+            self.semaphore.release()
+
+    def route_code(self, route_code):
+        """Adjust route_code on the way through."""
+        if route_code is None:
+            return self.routing_code
+        return self.routing_code + _u("/") + route_code
+
+
 class MultiTestResult(TestResult):
     """A test result that dispatches to many test results."""
 
diff --git a/testtools/tests/test_testresult.py b/testtools/tests/test_testresult.py
index fb20884..c34fa37 100644
--- a/testtools/tests/test_testresult.py
+++ b/testtools/tests/test_testresult.py
@@ -36,6 +36,7 @@ from testtools import (
     TestByTestResult,
     TextTestResult,
     ThreadsafeForwardingResult,
+    ThreadsafeStreamResult,
     testresult,
     )
 from testtools.compat import (
@@ -1620,6 +1621,82 @@ class TestMergeTags(TestCase):
             expected, _merge_tags(current_tags, changing_tags))
 
 
+class TestThreadStreamResult(TestCase):
+
+    def make_result(self, target):
+        semaphore = threading.Semaphore(1)
+        return (ThreadsafeStreamResult(target, semaphore, "foo"),
+            semaphore)
+
+    def test_estimate(self):
+        class CallbackStream(object):
+            def estimate(stream, count, route_code=None, timestamp=None):
+                self.assertFalse(semaphore.acquire(False))
+                self.assertEqual(2, count)
+                self.assertEqual(expected_route, route_code)
+                self.assertEqual(expected_time, timestamp)
+        result, semaphore = self.make_result(CallbackStream())
+        expected_route = "foo"
+        expected_time = None
+        result.estimate(2, route_code=None, timestamp=None)
+        expected_route = "foo/bar"
+        expected_time = datetime.datetime.now(utc)
+        result.estimate(2, route_code="bar", timestamp=expected_time)
+
+    def test_file(self):
+        class CallbackStream(object):
+            def file(stream, file_name, file_bytes, eof=False, mime_type=None,
+                test_id=None, route_code=None, timestamp=None):
+                self.assertFalse(semaphore.acquire(False))
+                self.assertEqual("file", file_name)
+                self.assertEqual(_b("content"), file_bytes)
+                self.assertEqual(True, eof)
+                self.assertEqual("quux", mime_type)
+                self.assertEqual("test", test_id)
+                self.assertEqual(expected_route, route_code)
+                self.assertEqual(expected_time, timestamp)
+        result, semaphore = self.make_result(CallbackStream())
+        expected_route = "foo"
+        expected_time = None
+        result.file("file", _b("content"), eof=True, mime_type="quux",
+            test_id="test", route_code=None, timestamp=None)
+        expected_route = "foo/bar"
+        expected_time = datetime.datetime.now(utc)
+        result.file("file", _b("content"), eof=True, mime_type="quux",
+            test_id="test", route_code="bar", timestamp=expected_time)
+
+    def test_status(self):
+        class CallbackStream(object):
+            def status(stream, test_id, test_status, test_tags=None, runnable=True,
+                route_code=None, timestamp=None):
+                self.assertFalse(semaphore.acquire(False))
+                self.assertEqual("test", test_id)
+                self.assertEqual("fail", test_status)
+                self.assertEqual(set(["quux"]), test_tags)
+                self.assertEqual(False, runnable)
+                self.assertEqual(expected_route, route_code)
+                self.assertEqual(expected_time, timestamp)
+        result, semaphore = self.make_result(CallbackStream())
+        expected_route = "foo"
+        expected_time = None
+        result.status("test", "fail", test_tags=set(["quux"]), runnable=False,
+            route_code=None, timestamp=None)
+        expected_route = "foo/bar"
+        expected_time = datetime.datetime.now(utc)
+        result.status("test", "fail", test_tags=set(["quux"]), runnable=False,
+            route_code="bar", timestamp=expected_time)
+
+    def testStartTestRun(self):
+        t = object()
+        result, semaphore = self.make_result(t)
+        result.startTestRun()
+
+    def testStopTestRun(self):
+        t = object()
+        result, semaphore = self.make_result(t)
+        result.startTestRun()
+
+
 class TestExtendedToOriginalResultDecoratorBase(TestCase):
 
     def make_26_result(self):
